from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import numpy as np
import matplotlib.pyplot as plt
import os
import scipy.spatial

# takes in a list of proposals and truth generated by a full inference over a dataset
def produce_graphs(proposals, truth, num):
    ppn2_distances_to_closest_gt = []
    ppn2_distances_to_closest_pred = []
    for i in range(num):
        distances_ppn2 = scipy.spatial.distance.cdist(proposals[i], truth[i])
        try:
            ppn2_distances_to_closest_gt.extend(np.amin(distances_ppn2, axis=1))
        except ValueError:
            pass
        try:
            ppn2_distances_to_closest_pred.extend(np.amin(distances_ppn2, axis=0))
        except ValueError:
            pass
    plot_graphs(ppn2_distances_to_closest_gt, ppn2_distances_to_closest_pred)

def plot_graphs(gt, pred):
    bins = np.linspace(0, 100, 100)
    make_plot(
        gt,
        bins=50,
        xlabel="distance to nearest ground truth pixel",
        ylabel="#proposed pixels",
        filename='ppn2_distance_to_closest_gt_log.png'
    )
    make_plot(
        gt,
        bins=np.linspace(0, 5, 100),
        xlabel="distance to nearest ground truth pixel",
        ylabel="#proposed pixels",
        filename='ppn2_distance_to_closest_gt_zoom_log.png'
    )
    bins = np.linspace(0, 100, 100)
    make_plot(
        pred,
        bins=50,
        xlabel="distance to nearest proposed pixel",
        ylabel="#ground truth pixels",
        filename='ppn2_distance_to_closest_pred_log.png'
    )
    make_plot(
        pred,
        bins=np.linspace(0, 5, 100),
        xlabel="distance to nearest proposed pixel",
        ylabel="#ground truth pixels",
        filename='ppn2_distance_to_closest_pred_zoom_log.png'
    )

def make_plot(data, bins=None, xlabel="", ylabel="", filename=""):
    """
    If bins is None: discrete histogram
    """
    directory = './multichannel/demo_0.6/'
    data = np.array(data)
    if bins is None:
        d = np.diff(np.unique(data)).min()
        left_of_first_bin = data.min() - float(d)/2
        right_of_last_bin = data.max() + float(d)/2
        bins = np.arange(left_of_first_bin, right_of_last_bin + d, d)

    plt.hist(data, bins, histtype = 'step')
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.yscale('log')
    if not os.path.isdir(directory):
        os.makedirs(directory)
    plt.savefig(directory + filename)
    plt.gcf().clear()

#should probably find an easy numpy function to use
def examine_proposals(original, new, num, distance_threshold, coord1, coord2):
    prune_indices = []
    for i in range(num):
        index = []
        original_modified = [elem[coord1] for elem in original[i]]
        new_modified = [elem[coord2] for elem in new[i]]
        for j in range(len(original_modified)):
            elem = original_modified[j]
            min_distance = np.inf
            for k in range(len(new_modified)):
                distance = np.absolute(elem - new_modified[k])
                if distance < min_distance:
                    min_distance = distance
            if min_distance > distance_threshold:
                index.append(j)
        prune_indices.append(index)
    return prune_indices

def delete_proposals(proposal, scores, labels, indices, num):
    for i in range(num):
        proposal[i] = np.delete(proposal[i], indices[i], axis=0)
        scores[i] = np.delete(scores[i], indices[i], axis=0)
        labels[i] = np.delete(labels[i], indices[i], axis=0)
    return proposal, scores, labels
        
        